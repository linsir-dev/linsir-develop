# 线程相关关键字示例

## 功能说明

本示例代码展示了Java中三个重要的线程相关关键字的功能和使用方法：

1. **volatile关键字**：
   - 保证变量的可见性（一个线程对变量的修改，其他线程能立即看到）
   - 禁止指令重排序
   - 不保证原子性

2. **synchronized关键字**：
   - 保证方法或代码块的原子性
   - 保证可见性（通过加锁和解锁的内存语义）
   - 保证有序性
   - 可以修饰方法、代码块和静态方法

3. **final关键字**：
   - 修饰基本类型变量：值不可变
   - 修饰引用类型变量：引用不可变，但引用对象的内部状态可以修改
   - 修饰方法：方法不可被重写
   - 修饰类：类不可被继承

## 示例代码结构

- **ThreadDemo.java**：包含三个内部类，分别演示三个关键字的功能：
  - **VolatileDemo**：演示volatile关键字的可见性和禁止指令重排序功能
  - **SynchronizedDemo**：演示synchronized关键字在方法级别、代码块级别和静态方法级别的使用
  - **FinalDemo**：演示final关键字修饰变量、方法和类的效果

## 运行说明

1. 编译并运行ThreadDemo.java文件
2. 观察控制台输出，了解三个关键字的功能和效果
3. 注意volatile和synchronized的区别：
   - volatile只保证可见性和有序性，不保证原子性
   - synchronized保证原子性、可见性和有序性
4. 注意final关键字的不同用法和效果

## 核心知识点

- **volatile**：适用于变量被多个线程共享，且变量的写操作不依赖于当前值的场景
- **synchronized**：适用于需要保证原子性操作的场景，如计数器、状态更新等
- **final**：适用于值或引用不需要被修改的场景，可以提高代码的可读性和安全性

## 示例场景

- **VolatileDemo**：模拟了一个写线程修改flag和count变量，读线程等待flag变为true后读取count的值，展示了volatile的可见性保证
- **SynchronizedDemo**：模拟了10个线程同时对计数器进行递增操作，展示了synchronized的原子性保证
- **FinalDemo**：展示了final修饰基本类型变量、引用类型变量、方法和类的效果