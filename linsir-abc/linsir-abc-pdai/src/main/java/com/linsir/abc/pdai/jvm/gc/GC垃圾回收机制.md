# GC垃圾回收机制

垃圾回收（Garbage Collection，GC）是Java虚拟机（JVM）的核心功能之一，它自动管理内存的分配和回收，避免了手动内存管理可能导致的内存泄漏和野指针问题。本文将详细介绍Java的垃圾回收机制。

## 1. 垃圾回收的基本概念

### 1.1 什么是垃圾？
- 在Java中，垃圾是指不再被任何活动线程引用的对象。
- 这些对象占用的内存空间可以被回收，用于分配新的对象。

### 1.2 垃圾回收的作用
- **自动内存管理**：无需程序员手动分配和释放内存
- **防止内存泄漏**：及时回收不再使用的对象
- **提高程序可靠性**：减少内存相关的错误

### 1.3 垃圾回收的特点
- **自动执行**：JVM会在适当的时候自动执行垃圾回收
- **不确定时间**：垃圾回收的执行时间是不确定的
- **暂停执行**：垃圾回收过程中会暂停应用程序的执行（STW - Stop The World）

## 2. 对象存活判断算法

### 2.1 引用计数法（Reference Counting）
- **原理**：为每个对象维护一个引用计数器，当有引用指向该对象时计数器加1，当引用失效时计数器减1，当计数器为0时对象可被回收。
- **优点**：实现简单，判断效率高
- **缺点**：无法解决循环引用问题

### 2.2 可达性分析算法（Reachability Analysis）
- **原理**：从GC Roots出发，通过引用链遍历所有可达的对象，不可达的对象被标记为垃圾。
- **GC Roots**：
  - 虚拟机栈中引用的对象
  - 本地方法栈中引用的对象
  - 方法区中类静态属性引用的对象
  - 方法区中常量引用的对象
- **优点**：可以解决循环引用问题
- **缺点**：实现复杂度较高

## 3. 垃圾回收算法

### 3.1 标记-清除算法（Mark-Sweep）
- **步骤**：
  1. **标记**：从GC Roots出发，标记所有可达的对象
  2. **清除**：清除所有未被标记的对象
- **优点**：实现简单
- **缺点**：
  - 会产生内存碎片
  - 清除过程效率较低

### 3.2 复制算法（Copying）
- **步骤**：
  1. 将内存分为两块大小相等的区域，每次只使用其中一块
  2. 当使用的区域满时，将其中的存活对象复制到另一块区域
  3. 清除原区域的所有对象
- **优点**：
  - 无内存碎片
  - 分配内存速度快（只需移动指针）
- **缺点**：内存利用率低，只有一半的内存可用

### 3.3 标记-整理算法（Mark-Compact）
- **步骤**：
  1. **标记**：从GC Roots出发，标记所有可达的对象
  2. **整理**：将所有存活的对象压缩到内存的一端
  3. **清除**：清除边界外的所有对象
- **优点**：
  - 无内存碎片
  - 内存利用率高
- **缺点**：整理过程需要移动对象，效率较低

### 3.4 分代收集算法（Generational Collection）
- **原理**：根据对象的生命周期将内存分为不同的代，对不同代采用不同的垃圾回收算法
- **内存分代**：
  - **年轻代（Young Generation）**：
    - Eden空间：新对象分配的主要区域
    - Survivor空间（S0和S1）：经过垃圾回收后仍然存活的对象
  - **老年代（Old Generation）**：存放经过多次垃圾回收后仍然存活的对象
- **回收策略**：
  - **年轻代**：使用复制算法（对象存活率低）
  - **老年代**：使用标记-清除或标记-整理算法（对象存活率高）

## 4. 垃圾收集器

### 4.1 Serial收集器
- **类型**：单线程收集器
- **特点**：
  - 只使用一个线程进行垃圾回收
  - 垃圾回收时会暂停所有用户线程（STW）
  - 适用于客户端应用
- **参数**：`-XX:+UseSerialGC`

### 4.2 ParNew收集器
- **类型**：Serial收集器的多线程版本
- **特点**：
  - 使用多个线程进行垃圾回收
  - 垃圾回收时会暂停所有用户线程（STW）
  - 适用于服务器应用
- **参数**：`-XX:+UseParNewGC`

### 4.3 Parallel Scavenge收集器
- **类型**：多线程收集器
- **特点**：
  - 关注吞吐量（吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾回收时间)）
  - 自适应调节策略
- **参数**：`-XX:+UseParallelGC`

### 4.4 Serial Old收集器
- **类型**：Serial收集器的老年代版本
- **特点**：使用标记-整理算法
- **参数**：`-XX:+UseSerialOldGC`

### 4.5 Parallel Old收集器
- **类型**：Parallel Scavenge收集器的老年代版本
- **特点**：使用标记-整理算法，关注吞吐量
- **参数**：`-XX:+UseParallelOldGC`

### 4.6 CMS收集器（Concurrent Mark Sweep）
- **类型**：并发收集器
- **特点**：
  - 关注响应时间
  - 垃圾回收过程与用户线程并发执行
  - 使用标记-清除算法
- **步骤**：
  1. 初始标记（STW）
  2. 并发标记
  3. 重新标记（STW）
  4. 并发清除
- **参数**：`-XX:+UseConcMarkSweepGC`

### 4.7 G1收集器（Garbage First）
- **类型**：分区收集器
- **特点**：
  - 关注响应时间和吞吐量的平衡
  - 将堆内存划分为多个大小相等的区域（Region）
  - 可以预测垃圾回收的停顿时间
  - 使用标记-整理算法
- **步骤**：
  1. 初始标记（STW）
  2. 并发标记
  3. 最终标记（STW）
  4. 筛选回收（STW）
- **参数**：`-XX:+UseG1GC`

## 5. 垃圾回收相关概念

### 5.1 引用类型
- **强引用（Strong Reference）**：默认的引用类型，只要强引用存在，对象就不会被回收
- **软引用（Soft Reference）**：当内存不足时，对象会被回收
- **弱引用（Weak Reference）**：下一次垃圾回收时，对象会被回收
- **虚引用（Phantom Reference）**：对象回收时会收到通知，几乎不使用

### 5.2 内存分配策略
- **指针碰撞（Bump the Pointer）**：内存空间连续时，通过移动指针分配内存
- **空闲列表（Free List）**：内存空间不连续时，通过空闲列表分配内存

### 5.3 内存分配担保
- 年轻代进行垃圾回收时，如果 Survivor 空间不足以容纳所有存活对象，会将部分对象直接晋升到老年代

### 5.4 晋升年龄阈值
- 对象在年轻代中经过多次垃圾回收后仍然存活，会被晋升到老年代
- 默认晋升年龄阈值为15（可以通过 `-XX:MaxTenuringThreshold` 参数调整）

## 6. 垃圾回收调优

### 6.1 调优目标
- **吞吐量优先**：适用于后台批处理任务
- **响应时间优先**：适用于交互式应用

### 6.2 调优参数
- **堆大小设置**：
  - `-Xms`：初始堆大小
  - `-Xmx`：最大堆大小
- **年轻代设置**：
  - `-XX:NewSize`：年轻代初始大小
  - `-XX:MaxNewSize`：年轻代最大大小
  - `-XX:SurvivorRatio`：Eden空间与Survivor空间的比例
- **垃圾收集器设置**：
  - `-XX:+UseSerialGC`：使用Serial收集器
  - `-XX:+UseParNewGC`：使用ParNew收集器
  - `-XX:+UseParallelGC`：使用Parallel Scavenge收集器
  - `-XX:+UseConcMarkSweepGC`：使用CMS收集器
  - `-XX:+UseG1GC`：使用G1收集器
- **其他参数**：
  - `-XX:MaxTenuringThreshold`：对象晋升老年代的年龄阈值
  - `-XX:ParallelGCThreads`：并行垃圾回收线程数
  - `-XX:ConcGCThreads`：并发垃圾回收线程数

### 6.3 调优步骤
1. **监控**：使用工具监控应用程序的内存使用情况和垃圾回收行为
2. **分析**：分析监控数据，找出内存使用问题和垃圾回收瓶颈
3. **调整**：根据分析结果调整JVM参数
4. **验证**：验证调整后的效果，重复上述步骤直至达到预期目标

## 7. 垃圾回收监控工具

### 7.1 JDK自带工具
- **jstat**：监控JVM的统计信息，包括垃圾回收情况
- **jmap**：生成堆转储快照，分析内存使用情况
- **jhat**：分析堆转储快照
- **jstack**：生成线程快照，分析线程状态
- **VisualVM**：可视化的JVM监控和分析工具

### 7.2 第三方工具
- **Eclipse Memory Analyzer (MAT)**：分析堆转储快照，查找内存泄漏
- **YourKit Java Profiler**：商业级的Java性能分析工具
- **JProfiler**：商业级的Java性能分析工具

## 8. 常见内存问题及解决方案

### 8.1 内存泄漏（Memory Leak）
- **症状**：内存使用持续增长，最终导致OutOfMemoryError
- **原因**：
  - 长生命周期的对象持有短生命周期对象的引用
  - 集合类未及时清理元素
  - 监听器未正确注销
  - 线程局部变量（ThreadLocal）使用不当
- **解决方案**：
  - 使用弱引用存储临时对象
  - 及时清理不再使用的集合元素
  - 正确注销监听器
  - 避免ThreadLocal的滥用

### 8.2 内存溢出（OutOfMemoryError）
- **症状**：应用程序抛出OutOfMemoryError异常
- **原因**：
  - 堆内存不足
  - 方法区内存不足
  - 栈内存不足
- **解决方案**：
  - 增加堆内存大小（-Xmx）
  - 优化对象的生命周期
  - 减少大对象的创建
  - 合理设置方法区大小

### 8.3 频繁垃圾回收
- **症状**：应用程序响应缓慢，垃圾回收日志显示频繁的垃圾回收
- **原因**：
  - 年轻代空间过小
  - 对象创建速度过快
  - 大对象直接进入老年代
- **解决方案**：
  - 增加年轻代空间大小
  - 优化对象的创建和使用
  - 避免创建过大的对象

## 9. 垃圾回收的发展趋势

### 9.1 低延迟垃圾回收
- **目标**：减少垃圾回收的停顿时间，提高应用程序的响应速度
- **代表**：G1收集器、ZGC、Shenandoah收集器

### 9.2 并发垃圾回收
- **目标**：减少垃圾回收对应用程序的影响，提高系统的整体吞吐量
- **代表**：CMS收集器、G1收集器、ZGC

### 9.3 自适应垃圾回收
- **目标**：根据应用程序的运行情况自动调整垃圾回收策略
- **代表**：Parallel Scavenge收集器的自适应调节策略

## 10. 总结

Java的垃圾回收机制是JVM的核心功能之一，它通过自动管理内存的分配和回收，减轻了程序员的负担，提高了程序的可靠性。了解垃圾回收的工作原理和调优方法，对于开发高性能、高可靠性的Java应用程序至关重要。

在实际应用中，我们应该根据应用程序的特点选择合适的垃圾收集器和调优参数，通过监控和分析垃圾回收行为，不断优化内存使用，以达到最佳的性能表现。