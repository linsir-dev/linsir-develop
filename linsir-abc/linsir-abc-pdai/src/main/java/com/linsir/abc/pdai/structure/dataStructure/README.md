# 数据结构示例代码

本目录包含了各种数据结构的示例代码，包括线性结构、树形结构等。每个数据结构都有详细的实现和测试代码，以及应用场景的说明。

## 目录结构

```
dataStructure/
├── ArrayDemo.java          // 数组示例
├── LinkedListDemo.java     // 链表示例
├── HashMapDemo.java        // 哈希表示例
├── BinaryTreeDemo.java     // 二叉树示例
├── VLTreeDemo.java         // Van Emde Boas树示例
├── RedBlackTreeDemo.java   // 红黑树示例
├── BTreeDemo.java          // B树示例
├── BPlusTreeDemo.java      // B+树示例
├── BStarTreeDemo.java      // B*树示例
├── RTreeDemo.java          // R树示例
├── TrieTreeDemo.java       // Trie树示例
├── DataStructureTest.java  // 测试所有数据结构
└── README.md               // 说明文档
```

## 数据结构列表

### 1. 数组 (Array)
- **特点**：连续存储，随机访问时间复杂度O(1)
- **应用场景**：需要频繁随机访问元素的场景
- **示例操作**：创建、初始化、访问、修改、遍历、排序、查找

### 2. 链表 (Linked List)
- **特点**：非连续存储，插入删除时间复杂度O(1)
- **应用场景**：需要频繁插入删除操作的场景
- **示例操作**：添加、删除、查找、遍历

### 3. 哈希表 (Hash Table)
- **特点**：键值对存储，平均操作时间复杂度O(1)
- **应用场景**：需要快速查找、插入、删除的场景
- **示例操作**：添加、删除、查找、遍历

### 4. 二叉树 (Binary Tree)
- **特点**：每个节点最多有两个子节点
- **应用场景**：排序、搜索、表达式解析
- **示例操作**：插入、删除、查找、遍历（前序、中序、后序、层序）

### 5. Van Emde Boas树 (VL树)
- **特点**：高效存储和查询整数，时间复杂度O(log log M)
- **应用场景**：需要高效处理整数键的场景
- **示例操作**：插入、删除、查找、前驱、后继

### 6. 红黑树 (Red-Black Tree)
- **特点**：自平衡二叉搜索树，保证树的高度为O(log n)
- **应用场景**：需要保持平衡的搜索场景
- **示例操作**：插入、删除、查找、遍历

### 7. B树 (B Tree)
- **特点**：多路搜索树，适合外部存储
- **应用场景**：数据库和文件系统索引
- **示例操作**：插入、删除、查找、遍历

### 8. B+树 (B+ Tree)
- **特点**：所有键在叶子节点，形成有序链表
- **应用场景**：需要频繁范围查询的场景
- **示例操作**：插入、删除、查找、范围查询

### 9. B*树 (B* Tree)
- **特点**：B+树的变体，更高的空间利用率
- **应用场景**：写入密集的场景
- **示例操作**：插入、删除、查找、范围查询

### 10. R树 (R Tree)
- **特点**：空间索引数据结构，存储空间对象的MBR
- **应用场景**：地理信息系统、空间数据库
- **示例操作**：插入、删除、范围查询

### 11. Trie树 (Trie Tree)
- **特点**：前缀树，高效存储和检索字符串
- **应用场景**：自动补全、拼写检查、前缀匹配
- **示例操作**：插入、删除、查找、前缀查询

## 运行测试

运行`DataStructureTest.java`类的main方法，可以测试所有数据结构的示例代码：

```bash
# 在项目根目录执行
mvn exec:java -Dexec.mainClass="com.linsir.abc.pdai.structure.dataStructure.DataStructureTest"
```

## 数据结构比较

| 数据结构 | 时间复杂度 (平均) | 时间复杂度 (最坏) | 空间复杂度 | 主要特点 |
|---------|----------------|----------------|-----------|--------|
| 数组 | O(1) 访问 | O(n) 插入/删除 | O(n) | 连续存储，随机访问快 |
| 链表 | O(n) 访问 | O(n) 访问 | O(n) | 非连续存储，插入删除快 |
| 哈希表 | O(1) | O(n) | O(n) | 键值对存储，查找快 |
| 二叉树 | O(log n) | O(n) | O(n) | 树形结构，排序方便 |
| VL树 | O(log log M) | O(log log M) | O(M) | 高效处理整数键 |
| 红黑树 | O(log n) | O(log n) | O(n) | 自平衡，性能稳定 |
| B树 | O(log_m n) | O(log_m n) | O(n) | 多路搜索，适合外部存储 |
| B+树 | O(log_m n) | O(log_m n) | O(n) | 范围查询高效 |
| B*树 | O(log_m n) | O(log_m n) | O(n) | 空间利用率高 |
| R树 | O(log_m n) | O(log_m n) | O(n) | 空间索引 |
| Trie树 | O(L) | O(L) | O(ALPHABET_SIZE * L * N) | 前缀匹配高效 |

注：
- n 是数据元素的数量
- m 是树的阶
- L 是字符串的长度
- M 是整数的范围
- ALPHABET_SIZE 是字符集的大小

## 应用场景建议

1. **需要频繁随机访问**：使用数组
2. **需要频繁插入删除**：使用链表
3. **需要键值对存储**：使用哈希表
4. **需要排序和搜索**：使用二叉搜索树或红黑树
5. **需要处理整数键**：使用VL树
6. **需要平衡的搜索树**：使用红黑树
7. **需要外部存储索引**：使用B树、B+树或B*树
8. **需要范围查询**：使用B+树
9. **需要空间索引**：使用R树
10. **需要字符串前缀匹配**：使用Trie树

## 实现说明

- 所有数据结构的实现都包含了基本操作和应用示例
- 每个数据结构都有详细的注释，说明其原理和使用方法
- 测试类`DataStructureTest.java`包含了所有数据结构的测试用例
- 代码风格统一，易于理解和扩展

## 参考资料

- 《数据结构与算法分析》
- 《算法导论》
- 《计算机程序设计艺术》
- [Wikipedia - Data Structures](https://en.wikipedia.org/wiki/List_of_data_structures)
- [GeeksforGeeks - Data Structures](https://www.geeksforgeeks.org/data-structures/)
