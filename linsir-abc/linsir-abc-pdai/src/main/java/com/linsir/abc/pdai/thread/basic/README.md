# 基础线程机制示例

## 功能说明

本示例代码展示了Java中基础线程机制的各种功能，包括：

1. **线程的生命周期和状态**：展示了线程从创建到结束的各个状态
2. **线程的优先级**：展示了线程优先级的设置和影响
3. **线程的中断**：展示了如何中断线程以及线程如何响应中断
4. **线程的等待和通知**：展示了线程间的协作机制
5. **线程的睡眠和加入**：展示了线程的睡眠操作和线程间的等待
6. **守护线程**：展示了守护线程的特性和使用场景

## 示例代码结构

- **BasicThreadDemo.java**：包含六个内部类，分别演示基础线程机制的不同方面：
  - **ThreadStateDemo**：演示线程的生命周期和状态转换
  - **ThreadPriorityDemo**：演示线程优先级的设置和效果
  - **ThreadInterruptDemo**：演示线程的中断机制
  - **ThreadWaitNotifyDemo**：演示线程的等待和通知机制
  - **ThreadSleepJoinDemo**：演示线程的睡眠和加入操作
  - **DaemonThreadDemo**：演示守护线程的特性

## 运行说明

1. 编译并运行BasicThreadDemo.java文件
2. 观察控制台输出，了解不同线程机制的功能和效果
3. 注意线程状态的转换过程
4. 注意线程优先级对执行顺序的影响（不保证绝对顺序）
5. 注意守护线程和用户线程的区别

## 核心知识点

- **线程的状态**：NEW、RUNNABLE、BLOCKED、WAITING、TIMED_WAITING、TERMINATED
- **线程的优先级**：范围1-10，默认5，优先级高的线程获得CPU时间片的概率更大
- **线程的中断**：通过interrupt()方法中断线程，线程通过isInterrupted()检查中断状态
- **等待/通知机制**：通过wait()、notify()、notifyAll()方法实现线程间协作
- **线程睡眠**：通过sleep()方法使线程进入TIMED_WAITING状态
- **线程加入**：通过join()方法等待其他线程结束
- **守护线程**：通过setDaemon(true)设置，当所有用户线程结束时自动终止

## 示例场景

- **ThreadStateDemo**：模拟了线程从创建到结束的完整生命周期，展示了各个状态的转换
- **ThreadPriorityDemo**：创建了三个不同优先级的线程，展示了优先级对执行的影响
- **ThreadInterruptDemo**：演示了两种中断线程的场景：通过中断标志结束线程和在睡眠时被中断
- **ThreadWaitNotifyDemo**：模拟了生产者-消费者模式，展示了线程间的等待和通知机制
- **ThreadSleepJoinDemo**：演示了线程的睡眠操作和通过join()方法等待其他线程结束
- **DaemonThreadDemo**：创建了一个守护线程和一个用户线程，展示了守护线程在所有用户线程结束时自动终止的特性

## 最佳实践

- **线程状态管理**：合理使用线程状态，避免线程长时间阻塞或等待
- **线程优先级**：不要过度依赖线程优先级，它只是一个调度提示
- **线程中断**：正确处理线程中断，避免忽略InterruptedException
- **等待/通知机制**：使用while循环检查条件，避免虚假唤醒
- **线程同步**：合理使用同步机制，避免死锁和活锁
- **守护线程**：只在必要时使用守护线程，例如后台服务、监控任务等

## 注意事项

- 线程状态的转换是由JVM和操作系统控制的，代码中只是模拟了转换过程
- 线程优先级不保证绝对的执行顺序，只是影响获得CPU时间片的概率
- 中断线程只是设置一个中断标志，线程需要自己响应中断
- 等待/通知机制必须在同步代码块中使用
- 守护线程中不要执行重要的业务逻辑，因为它可能会在任何时候被终止
- 线程的创建和销毁是有开销的，对于大量的短期任务，建议使用线程池