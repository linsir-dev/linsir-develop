# 设计模式技术文档

## 文档列表

1. [什么是设计模式？](what-is-design-pattern.md)
2. [单例模式](singleton-pattern.md)
3. [工厂模式](factory-pattern.md)
4. [观察者模式](observer-pattern.md)
5. [策略模式](strategy-pattern.md)
6. [装饰器模式](decorator-pattern.md)
7. [代理模式](proxy-pattern.md)

## 学习路径

### 初学者
1. 什么是设计模式？ → 了解设计模式的基本概念和分类
2. 单例模式 → 学习最简单的创建型模式
3. 工厂模式 → 学习创建型模式的进阶内容

### 进阶者
1. 观察者模式 → 学习行为型模式
2. 策略模式 → 学习如何封装算法
3. 装饰器模式 → 学习结构型模式
4. 代理模式 → 学习如何控制对象访问

### 高级者
1. 深入理解所有设计模式的原理
2. 在实际项目中灵活应用设计模式
3. 能够根据实际情况选择合适的设计模式
4. 能够创造新的设计模式

## 核心概念

### 设计模式的分类

#### 创建型模式（Creational Patterns）
创建型模式关注对象的创建过程，将对象的创建和使用分离：
- 单例模式（Singleton）
- 工厂方法模式（Factory Method）
- 抽象工厂模式（Abstract Factory）
- 建造者模式（Builder）
- 原型模式（Prototype）

#### 结构型模式（Structural Patterns）
结构型模式关注类和对象的组合，通过继承或组合来构建更大的结构：
- 适配器模式（Adapter）
- 桥接模式（Bridge）
- 组合模式（Composite）
- 装饰器模式（Decorator）
- 外观模式（Facade）
- 享元模式（Flyweight）
- 代理模式（Proxy）

#### 行为型模式（Behavioral Patterns）
行为型模式关注对象之间的通信和职责分配：
- 策略模式（Strategy）
- 模板方法模式（Template Method）
- 观察者模式（Observer）
- 迭代器模式（Iterator）
- 责任链模式（Chain of Responsibility）
- 命令模式（Command）
- 备忘录模式（Memento）
- 状态模式（State）
- 访问者模式（Visitor）
- 中介者模式（Mediator）
- 解释器模式（Interpreter）

### 设计模式的六大原则

#### 1. 单一职责原则（Single Responsibility Principle，SRP）
一个类只负责一项职责。

#### 2. 开闭原则（Open-Closed Principle，OCP）
软件实体应该对扩展开放，对修改关闭。

#### 3. 里氏替换原则（Liskov Substitution Principle，LSP）
子类可以替换父类出现在父类能够出现的任何地方。

#### 4. 接口隔离原则（Interface Segregation Principle，ISP）
使用多个专门的接口，而不是使用单一的总接口。

#### 5. 依赖倒置原则（Dependency Inversion Principle，DIP）
高层模块不应该依赖低层模块，两者都应该依赖其抽象。

#### 6. 迪米特法则（Law of Demeter，LoD）
一个对象应该对其他对象有尽可能少的了解。

## 设计模式对比

### 创建型模式对比

| 模式 | 目的 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|----------|
| 单例模式 | 确保一个类只有一个实例 | 内存占用少、全局访问 | 违反单一职责、难以测试 | 配置管理器、数据库连接池 |
| 工厂方法 | 定义创建对象的接口 | 符合开闭原则 | 增加类的数量 | 日志记录器、数据库连接 |
| 抽象工厂 | 创建一组相关对象 | 支持产品族 | 难以扩展新产品等级 | 跨平台 UI、数据库访问 |
| 建造者模式 | 分步骤创建复杂对象 | 灵活创建复杂对象 | 增加类的数量 | 复杂对象构建 |
| 原型模式 | 通过复制创建对象 | 避免重复创建 | 需要实现克隆接口 | 创建成本高的对象 |

### 结构型模式对比

| 模式 | 目的 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|----------|
| 适配器模式 | 接口转换 | 复用现有类 | 增加类的数量 | 接口不兼容 |
| 桥接模式 | 分离抽象和实现 | 灵活扩展 | 增加复杂度 | 多维度变化 |
| 组合模式 | 树形结构 | 统一处理 | 限制类型 | 树形结构 |
| 装饰器模式 | 动态添加职责 | 灵活扩展 | 增加复杂度 | 动态扩展功能 |
| 外观模式 | 简化接口 | 降低复杂度 | 不符合开闭原则 | 简化复杂系统 |
| 享元模式 | 共享对象 | 减少内存占用 | 增加复杂度 | 大量相似对象 |
| 代理模式 | 控制访问 | 职责清晰 | 增加复杂度 | 访问控制、延迟加载 |

### 行为型模式对比

| 模式 | 目的 | 优点 | 缺点 | 适用场景 |
|------|------|------|------|----------|
| 策略模式 | 封装算法 | 符合开闭原则 | 客户端必须知道策略 | 算法可替换 |
| 模板方法 | 定义算法骨架 | 复用代码 | 限制灵活性 | 算法步骤固定 |
| 观察者模式 | 一对多依赖 | 降低耦合 | 性能问题 | 事件处理、消息队列 |
| 迭代器模式 | 遍历集合 | 统一接口 | 增加类的数量 | 集合遍历 |
| 责任链模式 | 传递请求 | 解耦发送者和接收者 | 性能问题 | 审批流程 |
| 命令模式 | 封装请求 | 支持撤销/重做 | 增加类的数量 | 宏命令、撤销操作 |
| 备忘录模式 | 保存状态 | 不破坏封装 | 内存占用大 | 撤销操作、游戏存档 |
| 状态模式 | 状态转换 | 简化状态逻辑 | 增加类的数量 | 状态机 |
| 访问者模式 | 操作复杂对象结构 | 增加操作容易 | 增加元素困难 | 编译器、文档处理 |
| 中介者模式 | 集中通信 | 降低耦合 | 中介者复杂 | 多对象交互 |
| 解释器模式 | 解释语言 | 易于扩展 | 效率低 | 简单语言 |

## 常用设计模式

### 1. 单例模式

**核心思想**：确保一个类只有一个实例，并提供一个全局访问点。

**实现方式**：
- 饿汉式
- 懒汉式
- 懒汉式（线程安全）
- 双重检查锁
- 静态内部类
- 枚举

**最佳实践**：使用枚举或静态内部类。

### 2. 工厂模式

**核心思想**：定义创建对象的接口，让子类决定实例化哪一个类。

**类型**：
- 简单工厂模式
- 工厂方法模式
- 抽象工厂模式

**最佳实践**：根据实际情况选择合适的工厂模式。

### 3. 观察者模式

**核心思想**：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

**实现方式**：
- 基本实现
- 使用 Java 内置的观察者模式

**最佳实践**：使用事件对象、使用过滤器、使用优先级。

### 4. 策略模式

**核心思想**：定义一系列算法，并将每个算法封装起来，使它们可以相互替换。

**实现方式**：
- 基本实现
- 使用工厂模式创建策略
- 使用枚举定义策略
- 使用 Lambda 表达式

**最佳实践**：使用工厂模式创建策略、使用枚举定义策略、使用 Lambda 表达式。

### 5. 装饰器模式

**核心思想**：在不改变现有对象结构的情况下，动态地给对象添加额外的职责。

**实现方式**：
- 基本实现
- 使用抽象装饰器
- 使用建造者模式创建装饰器

**最佳实践**：保持接口简单、使用抽象装饰器、使用建造者模式创建装饰器。

### 6. 代理模式

**核心思想**：为其他对象提供一种代理以控制对这个对象的访问。

**类型**：
- 远程代理
- 虚拟代理
- 保护代理
- 智能引用代理

**实现方式**：
- 静态代理
- 动态代理（JDK 动态代理）
- CGLIB 动态代理

**最佳实践**：使用动态代理、使用责任链、使用注解。

## 设计模式的使用场景

### 1. 需要复用代码

当需要在多个项目中复用代码时，可以使用设计模式。

### 2. 需要提高代码质量

当需要提高代码的可维护性、可扩展性和可靠性时，可以使用设计模式。

### 3. 需要解决特定问题

当遇到特定的问题时，可以使用相应的设计模式来解决问题。

### 4. 需要提高团队协作效率

当需要提高团队协作效率时，可以使用设计模式作为通用的语言。

## 设计模式的注意事项

### 1. 不要过度使用

设计模式是为了解决特定问题的，不要为了使用设计模式而使用设计模式。

### 2. 理解设计模式的原理

在使用设计模式之前，需要深入理解设计模式的原理和适用场景。

### 3. 根据实际情况选择

根据实际情况选择合适的设计模式，不要盲目使用。

### 4. 保持代码简洁

设计模式可能会增加代码的复杂度，需要保持代码的简洁性。

## 设计模式的最佳实践

### 1. 遵循设计原则

遵循设计模式的六大原则，确保代码的质量。

### 2. 使用合适的设计模式

根据实际情况选择合适的设计模式，不要盲目使用。

### 3. 保持代码简洁

设计模式可能会增加代码的复杂度，需要保持代码的简洁性。

### 4. 持续学习和实践

设计模式需要持续学习和实践，才能更好地掌握。

## 参考资源

### 经典书籍
- 《设计模式：可复用面向对象软件的基础》- GoF
- 《Head First 设计模式》- Eric Freeman
- 《重构：改善既有代码的设计》- Martin Fowler

### 在线资源
- [Refactoring.Guru](https://refactoring.guru/design-patterns)
- [SourceMaking](https://sourcemaking.com/design_patterns)
- [Java Design Patterns](https://java-design-patterns.com/)

### 实践项目
- Spring Framework
- JDK 源码
- Apache Commons
- Google Guava

## 常见问题

### 1. 什么时候使用设计模式？

当需要解决特定的问题，或者需要提高代码的可维护性、可扩展性和可靠性时，可以使用设计模式。

### 2. 如何选择合适的设计模式？

根据实际问题的特点，选择合适的设计模式。可以参考设计模式的分类、优缺点和适用场景。

### 3. 设计模式会增加代码复杂度吗？

设计模式可能会增加代码的复杂度，但是可以提高代码的可维护性、可扩展性和可靠性。

### 4. 设计模式是银弹吗？

设计模式不是银弹，它只是解决特定问题的方案。不要为了使用设计模式而使用设计模式。

### 5. 如何学习设计模式？

学习设计模式需要循序渐进，从基本概念到深入理解，再到实际应用。建议先学习常用的设计模式，然后在实践中应用。