# ES查询中query和filter的区别

在ElasticSearch中，`query`和`filter`是两种常用的搜索方式，它们在功能和性能上有显著的区别。本文将详细介绍这两种查询方式的区别，以及何时使用它们。

## 核心区别

### 1. 计算得分 vs 不计算得分

- **query**：会计算文档与查询条件的相关性得分（relevance score），并根据得分对结果进行排序。
- **filter**：不会计算得分，只关心文档是否匹配条件。

### 2. 缓存行为

- **query**：默认情况下不会被缓存（某些情况下可能会缓存）。
- **filter**：会被自动缓存，以提高后续查询的性能。

### 3. 性能

- **query**：通常比filter慢，因为需要计算得分。
- **filter**：通常比query快，因为不需要计算得分，且结果会被缓存。

### 4. 使用场景

- **query**：适用于需要根据相关性排序的场景，如全文搜索。
- **filter**：适用于需要精确匹配且不需要排序的场景，如过滤状态、日期范围等。

## 详细比较

### 1. 得分计算

#### query查询

当使用`query`查询时，ElasticSearch会为每个匹配的文档计算一个相关性得分（_score）。这个得分反映了文档与查询条件的相关程度，得分越高，文档越相关。

得分计算基于以下因素：
- 词频（TF）：查询词在文档中出现的频率
- 逆文档频率（IDF）：查询词在整个索引中的稀有程度
- 字段长度归一化：字段越短，得分越高
- 其他因素：如查询词的权重、字段的权重等

#### filter查询

当使用`filter`查询时，ElasticSearch不会计算得分，所有匹配的文档都会被视为"匹配"，没有相关性排序。

### 2. 缓存机制

#### query查询

`query`查询的结果默认不会被缓存，因为：
- 查询条件可能包含复杂的得分计算，缓存成本较高
- 查询结果可能因索引的变化而频繁变化
- 全文搜索查询的重复性通常较低

#### filter查询

`filter`查询的结果会被自动缓存到ElasticSearch的过滤器缓存（filter cache）中，因为：
- 过滤器查询的结果是二进制的（匹配/不匹配），缓存成本低
- 过滤器查询的重复性通常较高（如过滤特定状态、日期范围等）
- 缓存过滤器结果可以显著提高后续相同查询的性能

### 3. 性能差异

由于上述差异，`filter`查询通常比`query`查询更快，尤其是在处理大型数据集时。

性能差异的主要原因：
- `filter`不需要计算得分，节省了计算资源
- `filter`结果会被缓存，避免了重复计算
- `filter`可以利用位图（bitSet）等优化技术，提高匹配速度

### 4. 使用场景

#### 适合使用query的场景

- **全文搜索**：需要根据相关性排序的场景，如搜索产品描述、文章内容等
- **模糊匹配**：需要考虑相关性的场景，如搜索"ElasticSearch tutorial"时，包含完整短语的文档应该排在前面
- **相关性排序**：任何需要根据文档与查询条件的相关程度排序的场景

#### 适合使用filter的场景

- **精确匹配**：如过滤特定状态、类别、ID等
- **范围查询**：如过滤特定日期范围、价格范围等
- **布尔过滤**：如过滤激活状态的用户、已发布的文章等
- **频繁重复的查询**：如用户经常按相同的条件过滤数据
- **组合查询中的非相关性条件**：在复杂查询中，将不需要计算得分的条件放在filter中

## 示例对比

### 使用query的示例

```json
{
  "query": {
    "match": {
      "title": "ElasticSearch tutorial"
    }
  }
}
```

### 使用filter的示例

```json
{
  "query": {
    "bool": {
      "filter": [
        {
          "term": {
            "status": "active"
          }
        },
        {
          "range": {
            "published_date": {
              "gte": "2023-01-01"
            }
          }
        }
      ]
    }
  }
}
```

### 组合使用query和filter

在实际应用中，经常需要组合使用`query`和`filter`，将需要计算得分的条件放在`query`中，将不需要计算得分的条件放在`filter`中。

```json
{
  "query": {
    "bool": {
      "must": [
        {
          "match": {
            "title": "ElasticSearch tutorial"
          }
        }
      ],
      "filter": [
        {
          "term": {
            "status": "active"
          }
        },
        {
          "range": {
            "published_date": {
              "gte": "2023-01-01"
            }
          }
        }
      ]
    }
  }
}
```

## 最佳实践

### 1. 优先使用filter

- 对于不需要计算得分的条件，优先使用filter而不是query
- 这样可以提高查询性能，并利用缓存机制

### 2. 组合使用query和filter

- 将需要相关性排序的条件放在query中
- 将不需要排序的条件放在filter中
- 这样可以获得相关性排序的同时，保持较好的性能

### 3. 注意缓存的影响

- 频繁变化的过滤条件可能不会从缓存中获益
- 考虑使用缓存键（cache key）来控制缓存行为

### 4. 监控和调优

- 监控查询性能，特别是在处理大型数据集时
- 根据实际情况调整query和filter的使用方式
- 考虑使用ElasticSearch的性能分析工具来识别瓶颈

### 5. 理解查询执行顺序

在布尔查询中，filter子句通常会在query子句之前执行，这样可以先过滤掉不匹配的文档，减少后续query计算的工作量。

## 总结

| 特性 | query | filter |
|------|-------|--------|
| 得分计算 | 计算相关性得分 | 不计算得分 |
| 结果排序 | 根据得分排序 | 不排序 |
| 缓存 | 通常不缓存 | 自动缓存 |
| 性能 | 相对较慢 | 相对较快 |
| 适用场景 | 全文搜索、相关性排序 | 精确匹配、范围查询、频繁重复的过滤 |

## 何时使用query vs filter

- **使用query**：当你需要根据相关性对结果进行排序时
- **使用filter**：当你只关心文档是否匹配特定条件，不需要排序时
- **组合使用**：当你需要相关性排序的同时，还需要过滤特定条件时

通过合理使用query和filter，可以显著提高ElasticSearch查询的性能和准确性，为用户提供更好的搜索体验。