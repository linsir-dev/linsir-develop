# IO模式示例

本目录包含 Java 中 5 种 IO 模式的示例代码，展示了不同 IO 模式的使用方法和特点。

## 目录结构
```
patterns/
├── BIODemo.java            // 阻塞IO（BIO）模式示例
├── NIODemo.java            // 非阻塞IO（NIO）模式示例
├── MultiplexedIODemo.java  // 多路复用IO模式示例
├── SignalDrivenIODemo.java // 信号驱动IO模式示例
├── AIODemo.java            // 异步IO（AIO）模式示例
├── IOTest.java             // IO模式测试主类
└── README.md               // 本说明文件
```

## 示例代码功能

### 1. 阻塞IO（BIO）模式
- **特点**：
  - 最传统的IO模式
  - 每个连接需要一个独立的线程处理
  - 读写操作会阻塞线程，直到操作完成
  - 简单直观，但并发性能差
- **使用场景**：
  - 连接数较少且固定的场景
  - 对性能要求不高的场景

### 2. 非阻塞IO（NIO）模式
- **特点**：
  - 基于通道（Channel）和缓冲区（Buffer）
  - 读写操作不会阻塞线程
  - 使用Selector（选择器）管理多个通道
  - 单个线程可以处理多个连接
  - 性能比BIO好，但编程复杂度较高
- **使用场景**：
  - 连接数较多的场景
  - 对性能有一定要求的场景

### 3. 多路复用IO模式
- **特点**：
  - 是NIO的核心实现
  - 通过Selector实现一个线程管理多个Channel
  - 利用操作系统的多路复用机制（如Linux的epoll、Windows的IOCP）
  - 性能比传统BIO和简单NIO好
- **使用场景**：
  - 高并发场景
  - 连接数多但每个连接数据量小的场景

### 4. 信号驱动IO模式
- **特点**：
  - 基于信号机制
  - 应用程序注册信号处理函数
  - 当IO就绪时，操作系统发送信号通知应用程序
  - 应用程序在信号处理函数中处理IO操作
  - 在Java中使用较少
- **使用场景**：
  - 对实时性要求较高的场景

### 5. 异步IO（AIO）模式
- **特点**：
  - 基于回调机制
  - 读写操作完全异步，不会阻塞线程
  - 当IO操作完成时，操作系统通知应用程序
  - 应用程序在回调函数中处理结果
  - 编程复杂度较高，但性能最好
- **使用场景**：
  - 高并发、大流量的场景
  - 对响应时间要求高的场景

## 示例代码内容

### BIODemo.java
- **功能**：
  - 展示阻塞IO（BIO）模式的使用方法
  - 演示每个连接一个线程的处理方式
  - 展示读写操作的阻塞特性

### NIODemo.java
- **功能**：
  - 展示非阻塞IO（NIO）模式的使用方法
  - 演示基于通道和选择器的处理方式
  - 展示单线程处理多连接的能力

### MultiplexedIODemo.java
- **功能**：
  - 展示多路复用IO模式的使用方法
  - 演示基于Selector的多路复用机制
  - 展示处理多个客户端连接的能力

### SignalDrivenIODemo.java
- **功能**：
  - 展示信号驱动IO模式的概念
  - 模拟信号驱动IO的工作原理
  - 说明Java中信号驱动IO的局限性

### AIODemo.java
- **功能**：
  - 展示异步IO（AIO）模式的使用方法
  - 演示基于回调机制的处理方式
  - 展示完全异步的IO操作

### IOTest.java
- **功能**：
  - 测试所有5种IO模式示例代码
  - 依次运行所有示例，验证它们的功能
  - 提供IO模式的总结和比较

## 运行示例

### 编译和运行
1. **编译**：确保所有 .java 文件已编译
   ```
   cd linsir-abc/linsir-abc-pdai/src/main/java
   javac -d ../../../../target com/linsir/abc/pdai/io/patterns/*.java
   ```

2. **运行**：执行 IOTest 类
   ```
   cd linsir-abc/linsir-abc-pdai
   java -cp target com.linsir.abc.pdai.io.patterns.IOTest
   ```

### 预期输出
运行后，你将看到各个IO模式的使用示例输出，包括服务器启动、客户端连接、消息收发等操作的结果。

## 注意事项

### 端口占用
- 每个IO模式示例使用不同的端口：
  - BIO: 8081
  - NIO: 8082
  - 多路复用IO: 8083
  - 信号驱动IO: 8084
  - AIO: 8085
- 确保这些端口未被其他程序占用

### 测试顺序
- 示例按照BIO → NIO → 多路复用IO → 信号驱动IO → AIO的顺序测试
- 每个测试之间有1秒的间隔，确保测试的独立性

### 信号驱动IO
- Java标准库未直接支持信号驱动IO
- 本示例使用Selector模拟信号驱动IO的概念

### 异步IO
- AIO操作是完全异步的，需要适当的等待时间确保操作完成
- 本示例中设置了3秒的等待时间

## 性能比较

| IO模式 | 阻塞特性 | 线程模型 | 性能 | 复杂度 | 适用场景 |
|--------|----------|----------|------|--------|----------|
| BIO    | 阻塞     | 一对一   | 低   | 低     | 连接数少 |
| NIO    | 非阻塞   | 一对多   | 中   | 中     | 连接数较多 |
| 多路复用IO | 非阻塞 | 一对多   | 高   | 中     | 高并发 |
| 信号驱动IO | 非阻塞 | 一对多   | 高   | 高     | 实时性要求高 |
| AIO    | 异步     | 一对多   | 最高 | 高     | 高并发、大流量 |

## 应用场景建议

1. **BIO**：适合简单的网络应用，如内部工具、管理系统等
2. **NIO**：适合大多数网络应用，如Web服务器、聊天服务器等
3. **多路复用IO**：适合高并发服务器，如大型网站、API网关等
4. **信号驱动IO**：适合实时性要求高的应用，如金融交易系统、实时监控等
5. **AIO**：适合大流量、低延迟的应用，如实时游戏服务器、高频交易系统等